/**
 * @file
 * @brief implementation of the todd phase polynomial optimization
 * @copyright Copyright(c) 2024 DVLab, GIEE, NTU, Taiwan
 */

#include <fmt/core.h>
#include <spdlog/spdlog.h>

#include <cstddef>
#include <ranges>
#include <unordered_map>
#include <unordered_set>

#include "../tableau_optimization.hpp"
#include "tableau/pauli_rotation.hpp"
#include "tableau/stabilizer_tableau.hpp"
#include "util/boolean_matrix.hpp"
#include "util/ordered_hashmap.hpp"
#include "util/phase.hpp"
#include "util/util.hpp"

extern bool stop_requested();

namespace qsyn::experimental {

namespace {
using Polynomial = std::vector<PauliRotation>;

/**
 * @brief Get the products between rows. returns matrix[0] * matrix[1], matrix[0] * matrix[2], ... matrix[1] * matrix[2], ...
 *
 * @param a_prime
 * @return dvlab::BooleanMatrix
 */
dvlab::BooleanMatrix get_row_products(dvlab::BooleanMatrix const& matrix) {
    auto row_products = dvlab::BooleanMatrix();

    row_products.reserve(matrix.num_rows() * (matrix.num_rows() - 1) / 2, matrix.num_cols());

    for (auto const& [a, b] : dvlab::combinations<2>(std::views::iota(0ul, matrix.num_rows()) | tl::to<std::vector>())) {
        row_products.push_row(matrix[a] * matrix[b]);
    }

    assert(row_products.num_rows() == matrix.num_rows() * (matrix.num_rows() - 1) / 2);

    return row_products;
}

/**
 * @brief Get the chi matrix object
 *
 * @param row_products the products between rows generated by get_row_products
 * @param z
 * @return dvlab::BooleanMatrix
 */
dvlab::BooleanMatrix get_chi_matrix(dvlab::BooleanMatrix const& row_products, dvlab::BooleanMatrix::Row const& z) {
    auto chi_matrix     = dvlab::BooleanMatrix();
    auto const num_rows = static_cast<size_t>(std::ceil(std::sqrt(row_products.num_rows() * 2)));

    auto const get_row_product_idx = [&num_rows](size_t a, size_t b) {
        if (a > b) {
            std::swap(a, b);
        }
        return a * num_rows - (a * (a + 1) / 2) + b - a - 1;
    };

    auto seen_rows    = std::unordered_set<dvlab::BooleanMatrix::Row, dvlab::BooleanMatrixRowHash>();
    auto const id_vec = std::views::iota(0ul, num_rows) | tl::to<std::vector>();

    for (auto const& [a, b, c] : dvlab::combinations<3>(id_vec)) {
        auto const new_row =
            z[a] * row_products[get_row_product_idx(b, c)] +
            z[b] * row_products[get_row_product_idx(a, c)] +
            z[c] * row_products[get_row_product_idx(a, b)];

        if (seen_rows.contains(new_row)) {
            continue;
        }

        if (new_row.is_zeros()) {
            continue;
        }
        seen_rows.insert(new_row);

        chi_matrix.push_row(new_row);
    }

    return chi_matrix;
}

/**
 * @brief Get the nullspace of a matrix.
 *
 * @param matrix
 * @return dvlab::BooleanMatrix
 */
dvlab::BooleanMatrix get_nullspace_transposed(dvlab::BooleanMatrix const& matrix) {
    auto augmented = hstack(dvlab::transpose(matrix), dvlab::identity(matrix.num_cols()));

    auto n_rows = matrix.num_cols();
    auto n_cols = matrix.num_rows();

    auto curr_pivot = size_t{0};

    for (auto const col : std::views::iota(0ul, n_cols)) {
        if (augmented[curr_pivot][col] == 0) {
            for (auto const row : std::views::iota(curr_pivot + 1, n_rows)) {
                if (augmented[row][col] != 0) {
                    augmented[curr_pivot] += augmented[row];
                    break;
                }
            }
        }

        if (augmented[curr_pivot][col] == 0) {
            continue;
        }

        for (auto const row : std::views::iota(curr_pivot + 1, n_rows)) {
            if (augmented[row][col] != 0) {
                augmented[row] += augmented[curr_pivot];
            }
        }

        ++curr_pivot;

        if (curr_pivot == n_rows) {
            break;
        }
    }

    auto nullspace = dvlab::BooleanMatrix(augmented.num_rows() - curr_pivot, augmented.num_cols() - n_cols);

    for (auto const row : std::views::iota(curr_pivot, augmented.num_rows())) {
        for (auto const col : std::views::iota(n_cols, augmented.num_cols())) {
            nullspace[row - curr_pivot][col - n_cols] = augmented[row][col];
        }
    }

    return nullspace;
}

dvlab::BooleanMatrix load_phase_poly_matrix(Polynomial const& polynomial) {
    auto const n_qubits = polynomial.front().n_qubits();

    auto phase_poly_matrix = dvlab::BooleanMatrix(n_qubits, polynomial.size());

    for (size_t i = 0; i < n_qubits; ++i) {
        for (size_t j = 0; j < polynomial.size(); ++j) {
            phase_poly_matrix[i][j] = polynomial[j].pauli_product().is_z_set(i);
        }
    }

    return phase_poly_matrix;
}

/**
 * @brief convert a boolean matrix to a list of Pauli rotations. Every two duplicated terms are removed.
 *
 * @param matrix
 * @return std::vector<PauliRotation>
 */
std::vector<PauliRotation> from_boolean_matrix(dvlab::BooleanMatrix const& matrix) {
    auto term_count_map = dvlab::utils::ordered_hashmap<dvlab::BooleanMatrix::Row, size_t, dvlab::BooleanMatrixRowHash>();
    for (auto const& row : matrix) {
        if (row.sum() == 0) {
            continue;
        }
        if (term_count_map.contains(row)) {
            term_count_map[row]++;
        } else {
            term_count_map.emplace(row, 1);
        }
    }
    // return matrix |
    return term_count_map |
           std::views::filter([](auto const& pair) { return pair.second % 2 == 1; }) |
           std::views::keys |
           std::views::transform([](auto const& row) -> PauliRotation {
               auto const pauli_vec = row |
                                      std::views::transform([](auto const x) { return x == 1 ? Pauli::z : Pauli::i; });
               return {pauli_vec, dvlab::Phase(1, 4)};
           }) |
           tl::to<std::vector>();
}

Polynomial todd_once(Polynomial const& polynomial) {
    if (polynomial.empty()) {
        return polynomial;
    }

    auto const n_qubits = polynomial.front().n_qubits();

    // Each column represents a term in the phase polynomial, and each row represents a qubit.
    auto const phase_poly_matrix = load_phase_poly_matrix(polynomial);

    auto seen_z        = std::unordered_set<dvlab::BooleanMatrix::Row, dvlab::BooleanMatrixRowHash>();
    auto const idx_vec = std::views::iota(0ul, polynomial.size()) | tl::to<std::vector>();

    auto const row_products = get_row_products(phase_poly_matrix);
    for (auto const& [a, b] : dvlab::combinations<2>(idx_vec)) {
        if (stop_requested()) {
            return polynomial;
        }
        dvlab::BooleanMatrix::Row z(n_qubits);
        for (size_t k = 0; k < n_qubits; ++k) {
            z[k] = phase_poly_matrix[k][a] ^ phase_poly_matrix[k][b];
        }
        if (seen_z.contains(z)) {
            continue;
        }

        seen_z.insert(z);

        // auto const chi_matrix = get_chi_matrix(phase_poly_matrix, z);
        auto const chi_matrix           = get_chi_matrix(row_products, z);
        auto const augmented_matrix     = vstack(phase_poly_matrix, chi_matrix);
        auto const nullspace_transposed = get_nullspace_transposed(augmented_matrix);

        if (nullspace_transposed.is_empty()) {
            continue;
        }

        for (auto const& y : nullspace_transposed) {
            if (y[a] == y[b]) continue;
            spdlog::debug("Found a TODD move");
            spdlog::debug("- a, b: {}, {}", a, b);
            spdlog::debug("- z: {}", fmt::join(z, ""));
            spdlog::debug("- y: {}", fmt::join(y, ""));
            auto phase_poly_matrix_copy = phase_poly_matrix;
            auto y_copy                 = y;
            if (y_copy.sum() % 2 == 1) {
                phase_poly_matrix_copy.push_zeros_column();
                y_copy.emplace_back(1);
            }

            for (auto const i : std::views::iota(0ul, phase_poly_matrix_copy.num_rows())) {
                if (z[i] == 1) {
                    phase_poly_matrix_copy[i] += y_copy;
                }
            }

            return from_boolean_matrix(dvlab::transpose(phase_poly_matrix_copy));
        }
    }

    return polynomial;
}

dvlab::BooleanMatrix get_l_matrix(dvlab::BooleanMatrix const& phase_poly_matrix, dvlab::BooleanMatrix const& row_products) {
    auto l_matrix       = phase_poly_matrix;
    auto const num_rows = phase_poly_matrix.num_rows();

    auto const get_row_product_idx = [&num_rows](size_t a, size_t b) {
        if (a > b) {
            std::swap(a, b);
        }
        return a * num_rows - (a * (a + 1) / 2) + b - a - 1;
    };

    auto const id_vec = std::views::iota(0ul, num_rows) | tl::to<std::vector>();

    for (auto const& [a, b] : dvlab::combinations<2>(id_vec)) {
        auto const new_row = row_products[get_row_product_idx(a, b)];
        // if (new_row.is_zeros()) {
        //     continue;
        // }
        l_matrix.push_row(new_row);
    }

    return l_matrix;
}

/**
 * z_matrix should both be computed in O(nm^2) time
 */

// dvlab::BooleanMatrix get_z_matrix(dvlab::BooleanMatrix const& phase_poly_matrix) {
//     // z_matrix copies the original phase_poly_matrix, then append the xors of the columns of it.
//     auto z_matrix_transposed = dvlab::transpose(phase_poly_matrix);
//     auto const num_cols      = phase_poly_matrix.num_cols();  // m
//     auto const n_qubits      = phase_poly_matrix.num_rows();  // n

//     auto const id_vec = std::views::iota(0ul, num_cols) | tl::to<std::vector>();
//     auto seen_z       = std::unordered_set<dvlab::BooleanMatrix::Row, dvlab::BooleanMatrixRowHash>();

//     if (phase_poly_matrix.num_cols() < 2) {  // early return
//         return z_matrix_transposed;
//     }

//     for (auto const& [a, b] : dvlab::combinations<2>(id_vec)) {
//         if (stop_requested()) {
//             return z_matrix_transposed;
//         }
//         dvlab::BooleanMatrix::Row new_col(n_qubits);
//         for (size_t k = 0; k < n_qubits; ++k) {
//             new_col[k] = phase_poly_matrix[k][a] ^ phase_poly_matrix[k][b];
//         }

//         if (seen_z.contains(new_col)) {
//             continue;
//         }
//         seen_z.insert(new_col);

//         z_matrix_transposed.push_row(new_col);
//     }
//     return z_matrix_transposed;
// }

/**
 * s_matrices should be created in O(nm^2)
 */

// std::vector<std::vector<std::pair<int, int>>> get_s_matrices(dvlab::BooleanMatrix const& phase_poly_matrix, dvlab::BooleanMatrix const& z_matrix) {
//     std::vector<std::vector<std::pair<int, int>>> s;
//     auto phase_poly_matrix_transposed = dvlab::transpose(phase_poly_matrix);
//     auto const n_qubits               = phase_poly_matrix.num_rows();
//     auto const id_vec                 = std::views::iota(0ul, phase_poly_matrix.num_cols()) | tl::to<std::vector>();

//     for (auto& z : z_matrix.get_matrix()) {
//         std::vector<std::pair<int, int>> s_z;
//         // a != b
//         for (auto const& [a, b] : dvlab::combinations<2>(id_vec)) {
//             dvlab::BooleanMatrix::Row tmp(n_qubits);
//             for (size_t k = 0; k < n_qubits; ++k) {
//                 tmp[k] = phase_poly_matrix[k][a] ^ phase_poly_matrix[k][b];
//             }
//             if (tmp == z) {
//                 s_z.push_back(std::make_pair(a, b));
//             }
//         }
//         // a == b
//         for (auto a : std::views::iota(0ul, n_qubits)) {
//             if (phase_poly_matrix_transposed.get_row(a) == z) {
//                 s_z.push_back(std::make_pair(a, a));
//             }
//         }
//         s.push_back(s_z);
//     }

//     return s;
// }

/**
 * z_matrix and s_matrices should both be computed in O(nm^2) time
 */

std::unordered_map<dvlab::BooleanMatrix::Row, std::vector<std::pair<int, int>>, dvlab::BooleanMatrixRowHash> get_s_matrices(dvlab::BooleanMatrix const& phase_poly_matrix) {
    // z_matrix copies the original phase_poly_matrix, then append the xors of the columns of it.
    // auto z_matrix_transposed = dvlab::transpose(phase_poly_matrix);
    auto const phase_poly_matrix_transposed = dvlab::transpose(phase_poly_matrix);
    std::unordered_map<dvlab::BooleanMatrix::Row, std::vector<std::pair<int, int>>, dvlab::BooleanMatrixRowHash> s_matrices;
    auto const num_cols = phase_poly_matrix.num_cols();  // m
    // auto const n_qubits = phase_poly_matrix.num_rows();  // n

    // initialize s_matrices
    for (auto i : std::views::iota(0ul, num_cols)) {
        auto const& col = phase_poly_matrix_transposed[i];
        if (s_matrices.contains(col)) {
            // add index to s_matrices
            s_matrices[col].push_back(std::make_pair(i, i));
            continue;
        }
        // new index to s_matrices
        s_matrices[col] = std::vector<std::pair<int, int>>{{i, i}};
    }

    auto const id_vec = std::views::iota(0ul, num_cols) | tl::to<std::vector>();
    if (phase_poly_matrix.num_cols() < 2) {  // early return
        return s_matrices;
    }

    for (auto const& [a, b] : dvlab::combinations<2>(id_vec)) {
        if (stop_requested()) {
            return s_matrices;
        }
        // dvlab::BooleanMatrix::Row new_col(n_qubits);
        // for (size_t k = 0; k < n_qubits; ++k) {
        //     new_col[k] = phase_poly_matrix[k][a] ^ phase_poly_matrix[k][b];
        // }
        dvlab::BooleanMatrix::Row const new_col = phase_poly_matrix_transposed[a] + phase_poly_matrix_transposed[b];

        if (s_matrices.contains(new_col)) {
            s_matrices[new_col].push_back(std::make_pair(a, b));
            continue;
        }
        s_matrices[new_col].push_back(std::make_pair(a, b));
    }
    return s_matrices;
}

int calculate_score(dvlab::BooleanMatrix::Row const& y, std::vector<std::pair<int, int>> const& s_matrix) {
    const int abs_y = static_cast<int>(y.sum() % 2);
    int ret         = -1 * abs_y;

    for (auto& indexes : s_matrix) {
        if (indexes.first == indexes.second) {
            ret += y[indexes.first] + 2 * (y[indexes.first] == 0) * (abs_y);
        } else {
            ret += 2 * (y[indexes.first] ^ y[indexes.second]);
        }
    }
    return ret;
}

Polynomial tohpe_once(Polynomial const& polynomial) {
    if (polynomial.empty()) {
        return polynomial;
    }

    // auto const n_qubits = polynomial.front().n_qubits();

    // Each column represents a term in the phase polynomial, and each row represents a qubit.
    auto const phase_poly_matrix = load_phase_poly_matrix(polynomial);

    auto const idx_vec = std::views::iota(0ul, polynomial.size()) | tl::to<std::vector>();

    auto const row_products = get_row_products(phase_poly_matrix);

    auto const l_matrix = get_l_matrix(phase_poly_matrix, row_products);
    // auto const z_matrix             = get_z_matrix(phase_poly_matrix);
    // auto const s_matrices           = get_s_matrices(phase_poly_matrix, z_matrix);
    auto const s_matrices           = get_s_matrices(phase_poly_matrix);
    auto const nullspace_transposed = get_nullspace_transposed(l_matrix);

    // check if y satisfies tohpe condition
    if (nullspace_transposed.is_empty()) {
        spdlog::debug("Empty nullspace");
        return polynomial;
    }

    auto phase_poly_matrix_copy = phase_poly_matrix;
    int max_score               = std::numeric_limits<int>::min();
    auto chosen_y               = dvlab::BooleanMatrix::Row(polynomial.size(), 0);
    auto max_z                  = s_matrices.begin()->first;
    for (auto const& y : nullspace_transposed) {
        if (y.is_zeros()) {
            continue;
        } else if ((y.sum() == y.size() && y.sum() % 2 == 0) || y.sum() != y.size()) {
            // y is the only candidate
            chosen_y = y;
            // traverse s_matrices to find z with best score
            for (auto it = s_matrices.begin(); it != s_matrices.end(); ++it) {
                auto const& s_matrix = it->second;
                auto score           = calculate_score(y, s_matrix);
                if (score > max_score) {
                    max_score = score;
                    max_z     = it->first;
                }
            }
        }
    }

    if (max_score < 0) {
        spdlog::debug("max_score < 0, Stop.");
        return polynomial;
    }

    if (chosen_y.is_zeros()) {
        spdlog::debug("y=0, Stop."); 
        return polynomial;
    }

    spdlog::debug("Found a TOHPE move");
    spdlog::debug("- z: {}", fmt::join(max_z, ""));
    spdlog::debug("- y: {}", fmt::join(chosen_y, ""));

    for (auto const i : std::views::iota(0ul, phase_poly_matrix_copy.num_rows())) {
        if (max_z[i] == 1) {
            phase_poly_matrix_copy[i] += chosen_y;
        }
    }

    phase_poly_matrix_copy = dvlab::transpose(phase_poly_matrix_copy);
    if (chosen_y.sum() % 2 == 1) {
        phase_poly_matrix_copy.push_row(max_z);
    }

    // no candidate, return same matrix
    return from_boolean_matrix(phase_poly_matrix_copy);
}

// int get_z_y_candidate(dvlab::BooleanMatrix const& phase_poly_matrix, dvlab::BooleanMatrix const& z_matrix, dvlab::BooleanMatrix const& nullspace_transposed, dvlab::BooleanMatrix::Row& max_y, dvlab::BooleanMatrix::Row& max_z) {
//     std::vector<std::vector<std::pair<int, int>>> s;
//     auto phase_poly_matrix_transposed = dvlab::transpose(phase_poly_matrix);
//     auto const n_qubits               = phase_poly_matrix.num_rows();
//     // auto const id_vec                 = std::views::iota(0ul, z_matrix.num_cols()) | tl::to<std::vector>();

//     int max_score        = std::numeric_limits<int>::min();
//     auto const z_col_vec = std::views::iota(0ul, z_matrix.num_cols()) | tl::to<std::vector>();
//     for (auto& z : z_matrix.get_matrix()) {
//         // X matrix
//         dvlab::BooleanMatrix x;

//         for (auto const& [a, b] : dvlab::combinations<2>(z_col_vec)) {
//             dvlab::BooleanMatrix::Row x_row(n_qubits);
//             for (size_t k = 0; k < n_qubits; ++k) {
//                 x_row[k] = (z[a] && (b == k)) ^ (z[b] && (a == k));
//             }
//             x.push_row(x_row);
//         }

//         // v
//         dvlab::BooleanMatrix v;
//         for (auto const& [a, b] : dvlab::combinations<2>(z_col_vec)) {
//             dvlab::BooleanMatrix::Row v_row(n_qubits);
//             for (size_t k = 0; k < n_qubits; ++k) {
//                 v_row[k] = z[a] & z[b];
//             }
//             v.push_row(v_row);
//         }

//         // generate y
//     }

//     if (max_score < 0) {
//         return -1;
//     }

//     return 0;
// }

// [[nodiscard]] int get_z_y_candidate_improved(dvlab::BooleanMatrix const& phase_poly_matrix, dvlab::BooleanMatrix const& z_matrix, dvlab::BooleanMatrix const& l_matrix, dvlab::BooleanMatrix::Row& max_y, dvlab::BooleanMatrix::Row& max_z) {
//     // Instead of finding y by brute force, now we try to find
//     // y_tilde and transform it back to y.
//     // Ref: Lower T-count by faster algorithm p.19-20

//     std::vector<std::vector<std::pair<int, int>>> const s;
//     auto phase_poly_matrix_transposed = dvlab::transpose(phase_poly_matrix);
//     auto const n_qubits               = phase_poly_matrix.num_rows();
//     // auto const id_vec                 = std::views::iota(0ul, z_matrix.num_cols()) | tl::to<std::vector>();

//     // The most important matrix: L_tilde (L in reduced row-echelon form)
//     auto l_tilde_matrix = l_matrix;
//     l_tilde_matrix.gaussian_elimination_augmented();

//     int max_score        = std::numeric_limits<int>::min();
//     auto const z_col_vec = std::views::iota(0ul, z_matrix.num_cols()) | tl::to<std::vector>();
//     auto const id_vec    = std::views::iota(0ul, phase_poly_matrix.num_cols()) | tl::to<std::vector>();

//     dvlab::BooleanMatrix x_matrix;
//     dvlab::BooleanMatrix x_tilde_matrix;
//     dvlab::BooleanMatrix v_tilde_matrix;

//     for (auto& z : z_matrix.get_matrix()) {
//         // s_z
//         std::vector<std::pair<int, int>> s_z;
//         // a != b
//         for (auto const& [a, b] : dvlab::combinations<2>(id_vec)) {
//             dvlab::BooleanMatrix::Row tmp(n_qubits);
//             for (size_t k = 0; k < n_qubits; ++k) {
//                 tmp[k] = phase_poly_matrix[k][a] ^ phase_poly_matrix[k][b];
//             }
//             if (tmp == z) {
//                 s_z.push_back(std::make_pair(a, b));
//             }
//         }
//         // a == b
//         for (auto a : std::views::iota(0ul, n_qubits)) {
//             if (phase_poly_matrix_transposed.get_row(a) == z) {
//                 s_z.push_back(std::make_pair(a, a));
//             }
//         }

//         dvlab::BooleanMatrix b_x_transpose;
//         dvlab::BooleanMatrix b_v_transpose;

//         // X matrix
//         for (auto const& [a, b] : dvlab::combinations<2>(z_col_vec)) {
//             dvlab::BooleanMatrix::Row x_row(n_qubits);
//             for (size_t k = 0; k < n_qubits; ++k) {
//                 x_row[k] = (z[a] && (b == k)) ^ (z[b] && (a == k));
//             }
//             x_matrix.push_row(x_row);
//         }

//         // dvlab::BooleanMatrix x_transpose = dvlab::transpose(x_matrix);

//         // B_x
//         for (size_t l = 0; l < x_matrix.num_cols(); ++l) {
//             dvlab::BooleanMatrix::Row b_x_col(l_tilde_matrix.num_cols(), 0);
//             for (size_t const row_idx : std::views::iota(0ul, l_tilde_matrix.num_rows())) {
//                 const auto& l_tilde = l_tilde_matrix[row_idx];

//                 // check X
//                 if (x_matrix[row_idx][l] != 1) continue;

//                 if (!l_tilde.is_one_hot()) continue;

//                 // find the one hot spot j
//                 size_t j = 0;
//                 for (size_t i = 0; i < l_tilde.size(); ++i) {
//                     if (l_tilde[i] == 1) {
//                         j = i;
//                         break;
//                     }
//                 }

//                 // xor
//                 for (auto i : std::views::iota(0ul, l_tilde.size())) {
//                     b_x_col[i] ^= l_tilde_matrix[i][j];
//                 }
//                 b_x_transpose.push_row(b_x_col);
//             }
//         }

//         // B_v
//         for (size_t l = 0; l < x_matrix.num_cols(); ++l) {
//             // Construct row of v
//             dvlab::BooleanMatrix::Row v_row(0);
//             for (auto i : std::views::iota(0ul, z_matrix.num_cols())) {
//                 v_row.emplace_back(z[i]);
//             }
//             for (auto const& [a, b] : dvlab::combinations<2>(z_col_vec)) {
//                 v_row.emplace_back(z[a] & z[b]);
//             }

//             dvlab::BooleanMatrix::Row b_v_col(l_tilde_matrix.num_cols(), 0);
//             for (size_t const row_idx : std::views::iota(0ul, v_row.size())) {
//                 if (v_row[row_idx] == 0) continue;

//                 const auto& l_tilde = l_tilde_matrix[row_idx];

//                 if (!l_tilde.is_one_hot()) continue;

//                 // find the one hot spot j
//                 size_t j = 0;
//                 for (size_t i = 0; i < l_tilde.size(); ++i) {
//                     if (l_tilde[i] == 1) {
//                         j = i;
//                         break;
//                     }
//                 }

//                 // xor
//                 for (auto i : std::views::iota(0ul, l_tilde.size())) {
//                     b_v_col[i] ^= l_tilde_matrix[i][j];
//                 }
//             }

//             for (auto i : std::views::iota(0ul, l_tilde_matrix.num_cols())) {
//                 v_row[i] ^= b_v_col[i];
//             }

//             b_v_transpose.push_row(b_v_col);
//             v_tilde_matrix.push_row(v_row);
//         }

//         // X_tilde matrix
//         for (size_t col_idx = 0; col_idx < x_matrix.num_cols(); ++col_idx) {
//             dvlab::BooleanMatrix::Row x_tilde_col(x_matrix.num_cols(), 0);
//             for (size_t row_idx = 0; row_idx < x_matrix.num_rows(); ++row_idx) {
//                 x_tilde_col[row_idx] = x_matrix[row_idx][col_idx] ^ b_x_transpose[col_idx][row_idx];
//             }
//             x_tilde_matrix.push_row(x_tilde_col);
//         }
//         x_tilde_matrix = dvlab::transpose(x_tilde_matrix);
//         v_tilde_matrix = dvlab::transpose(v_tilde_matrix);

//         auto const augmented_matrix     = hstack(x_tilde_matrix, v_tilde_matrix);
//         auto const augmented_b_matrix   = hstack(dvlab::transpose(b_x_transpose), dvlab::transpose(b_v_transpose));
//         auto const nullspace_transposed = get_nullspace_transposed(augmented_matrix);
//         auto phase_poly_matrix_copy     = phase_poly_matrix;

//         if (nullspace_transposed.is_empty()) {
//             continue;
//         }

//         for (auto const& augmented_y : nullspace_transposed) {
//             auto y = dvlab::matmul(augmented_b_matrix, augmented_y);
//             // y is candidate
//             int max_score    = std::numeric_limits<int>::min();
//             size_t max_index = 0;
//             for (auto a : std::views::iota(0ul, s_z.size())) {
//                 auto score = calculate_score(y, s_z);
//                 if (score > max_score) {
//                     max_score = score;
//                     max_index = a;
//                 }
//             }
//             max_z = z_matrix[max_index];
//             max_y = y;

//             spdlog::debug("Found a fastTODD move");
//             spdlog::debug("- z: {}", fmt::join(max_z, ""));
//             spdlog::debug("- y: {}", fmt::join(max_y, ""));

//             for (auto const i : std::views::iota(0ul, phase_poly_matrix_copy.num_rows())) {
//                 if (max_z[i] == 1) {
//                     phase_poly_matrix_copy[i] += y;
//                 }
//             }

//             phase_poly_matrix_copy = dvlab::transpose(phase_poly_matrix_copy);
//             if (y.sum() % 2 == 1) {
//                 phase_poly_matrix_copy.push_row(max_z);
//             }
//         }
//     }

//     if (max_score < 0) {
//         return -1;
//     }

//     return 0;
// }

[[nodiscard]] int get_z_y_candidate_v3(dvlab::BooleanMatrix const& phase_poly_matrix, dvlab::BooleanMatrix const& l_matrix, std::unordered_map<dvlab::BooleanMatrix::Row, std::vector<std::pair<int, int>>, dvlab::BooleanMatrixRowHash> const& s_matrices, dvlab::BooleanMatrix::Row& max_y, dvlab::BooleanMatrix::Row& max_z) {
    // Ref: Lower T-count by faster algorithm p.19-20
    auto max_score      = -1;
    auto const n_qubits = phase_poly_matrix.num_rows();

    // Calculate the reduced column echelon form of l_matrix
    // complexity:
    auto l_tilde_matrix_transpose = dvlab::transpose(l_matrix);
    l_tilde_matrix_transpose.gaussian_elimination_augmented();
    auto const l_tilde_matrix = dvlab::transpose(l_tilde_matrix_transpose);

    // Find all one-hot rows and record where their 1 is at
    // complexity: O(mn)
    std::unordered_map<size_t, size_t> j_candidates;
    for (size_t i = 0; i < l_tilde_matrix.num_rows(); ++i) {
        if (!l_tilde_matrix[i].is_one_hot())
            continue;

        for (size_t j = 0; j < l_tilde_matrix[i].size(); ++j) {
            if (l_tilde_matrix[i][j]) {
                j_candidates[i] = j;
                break;
            }
        }
    }

    for (auto it = s_matrices.begin(); it != s_matrices.end(); ++it) {
        auto const z     = it->first;
        auto const z_vec = std::views::iota(0ul, z.size()) | tl::to<std::vector>();
        // Calculate X matrix
        dvlab::BooleanMatrix x_matrix;
        for ([[maybe_unused]] auto i : std::views::iota(0ul, z.size())) {
            x_matrix.push_row(dvlab::BooleanMatrix::Row{n_qubits, 0});
        }
        for (auto const& [a, b] : dvlab::combinations<2>(z_vec)) {
            dvlab::BooleanMatrix::Row x_row(n_qubits);
            // for (size_t k = 0; k < n_qubits; ++k) {
            for (auto k : std::views::iota(0ul, n_qubits)) {
                x_row[k] = (z[a] && (b == k)) ^ (z[b] && (a == k));
            }
            x_matrix.push_row(x_row);
        }
        // auto x_matrix_transpose = dvlab::transpose(x_matrix);

        // Calculate v column
        dvlab::BooleanMatrix v_matrix_transpose;
        {
            dvlab::BooleanMatrix::Row v_row(0);
            for (auto i : std::views::iota(0ul, z.size())) {
                v_row.emplace_back(z[i]);
            }
            for (auto const& [a, b] : dvlab::combinations<2>(z_vec)) {
                v_row.emplace_back(z[a] & z[b]);
            }
            v_matrix_transpose.push_row(v_row);
        }

        // TODO: calculate B^X & B^V
        dvlab::BooleanMatrix b_x_transpose;
        dvlab::BooleanMatrix b_v_transpose;

        // B^x
        for (auto l : std::views::iota(0ul, x_matrix.num_cols())) {
            dvlab::BooleanMatrix::Row b_x_col(l_tilde_matrix.num_cols(), 0);
            for (auto row_idx : std::views::iota(0ul, x_matrix.num_rows())) {
                auto const& entry = x_matrix[row_idx][l];
                if (!entry) continue;
                if (!j_candidates.contains(row_idx)) continue;
                b_x_col += l_tilde_matrix_transpose[j_candidates[row_idx]];
            }
            b_x_transpose.push_row(b_x_col);
        }
        auto b_x = dvlab::transpose(b_x_transpose);

        // B_v
        {
            dvlab::BooleanMatrix::Row b_v_col(l_tilde_matrix.num_cols(), 0);
            for (auto row_idx : std::views::iota(0ul, x_matrix.num_rows())) {
                auto const& entry = v_matrix_transpose[0][row_idx];
                if (!entry) continue;
                if (!j_candidates.contains(row_idx)) continue;
                b_v_col += l_tilde_matrix_transpose[j_candidates[row_idx]];
            }
            b_v_transpose.push_row(b_v_col);
        }

        // Calculate y' & b
        auto& x_tilda_matrix = x_matrix;            // alias
        auto& v_tilda_matrix = v_matrix_transpose;  // alias
        for (auto i : std::views::iota(0ul, x_matrix.num_rows())) {
            x_tilda_matrix[i] += b_x[i];
        }

        v_tilda_matrix[0] += b_v_transpose[0];
        v_tilda_matrix = dvlab::transpose(v_tilda_matrix);

        auto augmented_matrix = dvlab::hstack(x_tilda_matrix, v_tilda_matrix);

        auto const augmented_nullspace_transposed = get_nullspace_transposed(augmented_matrix);

        if (augmented_nullspace_transposed.is_empty()) {
            spdlog::debug("Empty nullspace");
            continue;
        }

        // Calculate y
        auto b_matrix_hstack = dvlab::transpose(dvlab::vstack(b_x_transpose, b_v_transpose));

        // There may be improvement here
        // Why choose index=0?
        auto y = dvlab::matmul(b_matrix_hstack, augmented_nullspace_transposed[0]);

        // TODO: calculate the score and decide if you're gonna keep it
        auto score = calculate_score(y, it->second);
        if (score > max_score) {
            max_score = score;
            max_y     = y;
            max_z     = z;
        }
    }

    return (max_score < 0);
}

Polynomial fast_todd_once(Polynomial const& polynomial) {
    if (polynomial.empty()) {
        return polynomial;
    }

    // tohpe
    // copy polynomial because param is set to const
    Polynomial new_polynomial = polynomial;
    while (true) {
        auto const num_terms = polynomial.size();
        new_polynomial       = tohpe_once(new_polynomial);
        if (new_polynomial.empty() || new_polynomial.size() == num_terms) {
            break;
        }
    }

    // Each column represents a term in the phase polynomial, and each row represents a qubit.
    auto const phase_poly_matrix = load_phase_poly_matrix(new_polynomial);

    auto const idx_vec = std::views::iota(0ul, new_polynomial.size()) | tl::to<std::vector>();

    auto const row_products = get_row_products(phase_poly_matrix);

    auto const l_matrix = get_l_matrix(phase_poly_matrix, row_products);

    auto const phase_poly_matrix_transposed = dvlab::transpose(phase_poly_matrix);
    // auto const num_cols                     = phase_poly_matrix.num_cols();  // m
    auto const n_qubits   = phase_poly_matrix.num_rows();  // n
    auto const s_matrices = get_s_matrices(phase_poly_matrix);

    dvlab::BooleanMatrix::Row max_y(l_matrix.num_cols());
    dvlab::BooleanMatrix::Row max_z(n_qubits);

    if (!get_z_y_candidate_v3(phase_poly_matrix, l_matrix, s_matrices, max_y, max_z)) {
        // can't find candidate
        return new_polynomial;
    }

    spdlog::debug("Found a FastTodd move");
    spdlog::debug("- z: {}", fmt::join(max_z, ""));
    spdlog::debug("- y: {}", fmt::join(max_y, ""));

    auto phase_poly_matrix_copy = phase_poly_matrix;
    for (auto const i : std::views::iota(0ul, phase_poly_matrix_copy.num_rows())) {
        if (max_z[i] == 1) {
            phase_poly_matrix_copy[i] += max_y;
        }
    }

    phase_poly_matrix_copy = dvlab::transpose(phase_poly_matrix_copy);
    if (max_y.sum() % 2 == 1) {
        phase_poly_matrix_copy.push_row(max_z);
    }

    return from_boolean_matrix(phase_poly_matrix_copy);
}

}  // namespace

namespace {
class MultiLinearPolynomial {
public:
    void add_rotation(PauliRotation const& rotation, bool subtract = false) {
        if (!rotation.is_diagonal()) {
            return;
        }
        if (4 % rotation.phase().denominator() != 0) {
            return;
        }

        auto const ones =
            std::views::iota(0ul, rotation.n_qubits()) |
            std::views::filter([&rotation](size_t i) { return rotation.pauli_product().is_z_set(i); }) |
            tl::to<std::vector>();

        for (auto const& i : ones) {
            if (!_linear_terms.contains(i)) {
                _linear_terms.emplace(i, 0);
            }
            subtract ? _linear_terms[i] += 7 : _linear_terms[i] += 1;
            _linear_terms[i] %= 8;
        }

        for (auto const& [i, j] : dvlab::combinations<2>(ones)) {
            if (!_quadratic_terms.contains({i, j})) {
                _quadratic_terms.emplace(std::make_pair(i, j), 0);
            }
            subtract ? _quadratic_terms[{i, j}] += 3 : _quadratic_terms[{i, j}] += 1;
            _quadratic_terms[{i, j}] %= 4;
        }

        for (auto const& [i, j, k] : dvlab::combinations<3>(ones)) {
            if (!_cubic_terms.contains({i, j, k})) {
                _cubic_terms.emplace(i, j, k);
            } else {
                _cubic_terms.erase({i, j, k});
            }
        }
    }

    void add_rotations(std::vector<PauliRotation> const& rotations, bool subtract = false) {
        for (auto const& rotation : rotations) {
            add_rotation(rotation, subtract);
        }
    }

    bool is_clifford() const {
        return std::ranges::all_of(_linear_terms | std::views::values, [](size_t const& count) { return count % 2 == 0; }) &&
               std::ranges::all_of(_quadratic_terms | std::views::values, [](size_t const& count) { return count % 2 == 0; }) &&
               _cubic_terms.empty();
    }

    std::optional<CliffordOperatorString> extract_clifford_operators() const {
        if (!is_clifford()) {
            return std::nullopt;
        }

        auto clifford = CliffordOperatorString();
        for (auto const& [i, count] : _linear_terms) {
            switch (count) {
                case 0:
                    break;
                case 2:
                    clifford.emplace_back(CliffordOperatorType::s, std::array<size_t, 2>{i, 0});
                    break;
                case 4:
                    clifford.emplace_back(CliffordOperatorType::z, std::array<size_t, 2>{i, 0});
                    break;
                case 6:
                    clifford.emplace_back(CliffordOperatorType::sdg, std::array<size_t, 2>{i, 0});
                    break;
                default:
                    DVLAB_UNREACHABLE("The count should be 0, 2, 4, or 6");
            }
        }

        for (auto const& [pair, count] : _quadratic_terms) {
            auto const& [i, j] = pair;
            switch (count) {
                case 0:
                    break;
                case 2:
                    clifford.emplace_back(CliffordOperatorType::cz, std::array<size_t, 2>{i, j});
                    break;
                default:
                    DVLAB_UNREACHABLE("The count should be 0 or 2");
            }
        }

        return clifford;
    }

private:
    struct PairHash {
        size_t operator()(std::pair<size_t, size_t> const& pair) const {
            return std::hash<size_t>{}(pair.first) ^ std::hash<size_t>{}(pair.second);
        }
    };

    struct TripleHash {
        size_t operator()(std::tuple<size_t, size_t, size_t> const& triple) const {
            return std::hash<size_t>{}(std::get<0>(triple)) ^ std::hash<size_t>{}(std::get<1>(triple)) ^ std::hash<size_t>{}(std::get<2>(triple));
        }
    };

    std::unordered_map<size_t, size_t> _linear_terms;
    std::unordered_map<std::pair<size_t, size_t>, size_t, PairHash> _quadratic_terms;
    std::unordered_set<std::tuple<size_t, size_t, size_t>, TripleHash> _cubic_terms;
};
}  // namespace

std::pair<StabilizerTableau, Polynomial> ToddPhasePolynomialOptimizationStrategy::optimize(StabilizerTableau const& clifford, Polynomial const& polynomial) const {
    if (polynomial.empty()) {
        fmt::println("Polynomial is empty, returning the input Clifford and polynomial");
        return {clifford, polynomial};
    }

    if (std::ranges::any_of(polynomial, [](PauliRotation const& rotation) { return 4 % rotation.phase().denominator() != 0; })) {
        spdlog::error("Failed to perform TODD optimization: the polynomial contains a non-4th-root-of-unity phase!!");
        return {clifford, polynomial};
    }

    auto ret_clifford   = clifford;
    auto ret_polynomial = polynomial;

    properize(ret_clifford, ret_polynomial);

    auto multi_linear_polynomial = MultiLinearPolynomial();
    multi_linear_polynomial.add_rotations(ret_polynomial, false);

    spdlog::trace("Polynomial before TODD:\n{}", fmt::join(ret_polynomial, "\n"));
    spdlog::debug("num_terms before TODD: {}", ret_polynomial.size());

    while (true) {
        auto const num_terms = ret_polynomial.size();
        ret_polynomial       = todd_once(ret_polynomial);
        if (ret_polynomial.empty() || ret_polynomial.size() == num_terms) {
            break;
        }
        spdlog::trace("Polynomial after TODD:\n{}", fmt::join(ret_polynomial, "\n"));
        spdlog::debug("num_terms after TODD: {}", ret_polynomial.size());
    }

    multi_linear_polynomial.add_rotations(ret_polynomial, true);

    if (auto clifford_ops = multi_linear_polynomial.extract_clifford_operators(); clifford_ops.has_value()) {
        ret_clifford.apply(*clifford_ops);
    } else {
        spdlog::error("Failed to perform TODD optimization: the post-optimization polynomial does not have the same signature as the pre-optimization polynomial!!");
        return {clifford, polynomial};
    }

    return {ret_clifford, ret_polynomial};
}

std::pair<StabilizerTableau, Polynomial> TohpePhasePolynomialOptimizationStrategy::optimize(StabilizerTableau const& clifford, Polynomial const& polynomial) const {
    if (polynomial.empty()) {
        fmt::println("Polynomial is empty, returning the input Clifford and polynomial");
        return {clifford, polynomial};
    }

    if (std::ranges::any_of(polynomial, [](PauliRotation const& rotation) { return 4 % rotation.phase().denominator() != 0; })) {
        spdlog::error("Failed to perform Tohpe optimization: the polynomial contains a non-4th-root-of-unity phase!!");
        return {clifford, polynomial};
    }

    auto ret_clifford   = clifford;
    auto ret_polynomial = polynomial;

    properize(ret_clifford, ret_polynomial);

    auto multi_linear_polynomial = MultiLinearPolynomial();
    multi_linear_polynomial.add_rotations(ret_polynomial, false);

    spdlog::trace("Polynomial before Tohpe:\n{}", fmt::join(ret_polynomial, "\n"));
    spdlog::debug("num_terms before Tophe: {}", ret_polynomial.size());

    while (true) {
        auto const num_terms = ret_polynomial.size();
        ret_polynomial       = tohpe_once(ret_polynomial);
        if (ret_polynomial.empty() || ret_polynomial.size() == num_terms) {
            break;
        }
        spdlog::trace("Polynomial after TOHPE:\n{}", fmt::join(ret_polynomial, "\n"));
        spdlog::debug("num_terms after TOHPE: {}", ret_polynomial.size());
    }

    multi_linear_polynomial.add_rotations(ret_polynomial, true);

    if (auto clifford_ops = multi_linear_polynomial.extract_clifford_operators(); clifford_ops.has_value()) {
        ret_clifford.apply(*clifford_ops);
    } else {
        spdlog::error("Failed to perform TOHPE optimization: the post-optimization polynomial does not have the same signature as the pre-optimization polynomial!!");
        return {clifford, polynomial};
    }

    return {ret_clifford, ret_polynomial};
}

std::pair<StabilizerTableau, Polynomial> FastToddPhasePolynomialOptimizationStrategy::optimize(StabilizerTableau const& clifford, Polynomial const& polynomial) const {
    if (polynomial.empty()) {
        fmt::println("Polynomial is empty, returning the input Clifford and polynomial");
        return {clifford, polynomial};
    }

    if (std::ranges::any_of(polynomial, [](PauliRotation const& rotation) { return 4 % rotation.phase().denominator() != 0; })) {
        spdlog::error("Failed to perform Tohpe optimization: the polynomial contains a non-4th-root-of-unity phase!!");
        return {clifford, polynomial};
    }

    auto ret_clifford   = clifford;
    auto ret_polynomial = polynomial;

    properize(ret_clifford, ret_polynomial);

    auto multi_linear_polynomial = MultiLinearPolynomial();
    multi_linear_polynomial.add_rotations(ret_polynomial, false);

    spdlog::trace("Polynomial before FastTODD:\n{}", fmt::join(ret_polynomial, "\n"));
    spdlog::debug("num_terms before FastTODD: {}", ret_polynomial.size());

    while (true) {
        auto const num_terms = ret_polynomial.size();
        ret_polynomial       = fast_todd_once(ret_polynomial);
        if (ret_polynomial.empty() || ret_polynomial.size() == num_terms) {
            break;
        }
        spdlog::trace("Polynomial after FastTODD:\n{}", fmt::join(ret_polynomial, "\n"));
        spdlog::debug("num_terms after FastTODD: {}", ret_polynomial.size());
    }

    multi_linear_polynomial.add_rotations(ret_polynomial, true);

    if (auto clifford_ops = multi_linear_polynomial.extract_clifford_operators(); clifford_ops.has_value()) {
        ret_clifford.apply(*clifford_ops);
    } else {
        spdlog::error("Failed to perform TOHPE optimization: the post-optimization polynomial does not have the same signature as the pre-optimization polynomial!!");
        return {clifford, polynomial};
    }

    return {ret_clifford, ret_polynomial};
}

}  // namespace qsyn::experimental
