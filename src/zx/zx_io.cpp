/****************************************************************************
  PackageName  [ zx ]
  Synopsis     [ Define class ZXGraph Reader/Writer functions ]
  Author       [ Design Verification Lab ]
  Copyright    [ Copyright(c) 2023 DVLab, GIEE, NTU, Taiwan ]
****************************************************************************/

#include <fmt/ostream.h>
#include <spdlog/spdlog.h>

#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <functional>
#include <iterator>
#include <string>

#include "./zx_file_parser.hpp"
#include "./zxgraph.hpp"
#include "util/sysdep.hpp"
#include "util/tmp_files.hpp"

namespace qsyn::zx {

/**
 * @brief Read a ZXGraph
 *
 * @param filename
 * @param keepID if true, keep the IDs as written in file; if false, rearrange the vertex IDs
 * @return true if correctly constructed the graph
 * @return false
 */
bool ZXGraph::read_zx(std::filesystem::path const& filepath, bool keep_id) {
    // REVIEW - should we guard the case of no file extension?
    if (filepath.has_extension()) {
        if (filepath.extension() != ".zx") {
            fmt::println("unsupported file extension \"{}\"!!", filepath.extension().string());
            return false;
        }
    }

    ZXFileParser parser;

    return parser.parse(filepath.string()) && _build_graph_from_parser_storage(parser.get_storage(), keep_id);
}

/**
 * @brief Write a ZXGraph
 *
 * @param filename
 * @param complete
 * @return true if correctly write a graph into .zx
 * @return false
 */
bool ZXGraph::write_zx(std::filesystem::path const& filename, bool complete) const {
    std::ofstream zx_file;
    zx_file.open(filename);
    if (!zx_file.is_open()) {
        spdlog::error("Cannot open the file \"{}\"!!", filename.string());
        return false;
    }

    auto write_neighbors = [&zx_file, complete, this](ZXVertex* v) {
        for (const auto& [nb, etype] : this->get_neighbors(v)) {
            if ((complete) || (nb->get_id() >= v->get_id())) {
                zx_file << " ";
                switch (etype) {
                    case EdgeType::simple:
                        zx_file << "S";
                        break;
                    case EdgeType::hadamard:
                    default:
                        zx_file << "H";
                        break;
                }
                zx_file << nb->get_id();
            }
        }
        return true;
    };
    fmt::println(zx_file, "// Generated by qsyn " QSYN_VERSION ", DVLab, NTUEE");
    fmt::println(zx_file, "// inputs");

    for (ZXVertex* v : get_inputs()) {
        fmt::print(zx_file, "I{} ({}, {})", v->get_id(), v->get_qubit(), floor(v->get_col()));
        if (!write_neighbors(v)) {
            spdlog::error("failed to write neighbors for vertex {}", v->get_id());
            return false;
        }
        fmt::println(zx_file, "");
    }

    fmt::println(zx_file, "// outputs");

    for (ZXVertex* v : get_outputs()) {
        fmt::print(zx_file, "O{} ({}, {})", v->get_id(), v->get_qubit(), floor(v->get_col()));
        if (!write_neighbors(v)) {
            spdlog::error("failed to write neighbors for vertex {}", v->get_id());
            return false;
        }
        fmt::println(zx_file, "");
    }

    fmt::println(zx_file, "// non-boundary vertices");

    for (ZXVertex* v : _vertices) {
        if (v->is_boundary()) continue;
        fmt::print(zx_file, "{}{} ({}, {})",
                   v->is_z()   ? "Z"
                   : v->is_x() ? "X"
                               : "H",
                   v->get_id(),
                   v->get_row(),
                   floor(v->get_col()));

        if (!write_neighbors(v)) {
            spdlog::error("failed to write neighbors for vertex {}", v->get_id());
            return false;
        }

        if (v->get_phase() != (v->is_hbox() ? Phase(1) : Phase(0))) {
            fmt::print(zx_file, " {}", v->get_phase().get_ascii_string());
        }
        fmt::println(zx_file, "");
    }
    return true;
}

/**
 * @brief Build graph from parser storage
 *
 * @param storage
 * @param keepID
 * @return true
 * @return false
 */
bool ZXGraph::_build_graph_from_parser_storage(detail::StorageType const& storage, bool keep_id) {
    std::unordered_map<size_t, ZXVertex*> id2_vertex;

    for (auto& [id, info] : storage) {
        ZXVertex* v = std::invoke(
            // clang++ does not support structured binding capture by reference with OpenMP
            [&info = info, this]() {
                if (info.type == 'I')
                    return add_input(info.qubit, info.column);
                if (info.type == 'O')
                    return add_output(info.qubit, info.column);
                auto vtype = VertexType::boundary;
                if (info.type == 'Z')
                    vtype = VertexType::z;
                else if (info.type == 'X')
                    vtype = VertexType::x;
                else
                    vtype = VertexType::h_box;
                return add_vertex(vtype, info.phase, static_cast<float>(info.qubit), info.column);
            });

        if (keep_id) v->set_id(id);
        id2_vertex[id] = v;
    }

    for (auto& [vid, info] : storage) {
        for (auto& [type, nbid] : info.neighbors) {
            if (!id2_vertex.contains(nbid)) {
                spdlog::error("failed to build the graph: cannot find vertex with ID {}!!", nbid);
                return false;
            }
            auto const etype = (type == 'S') ? EdgeType::simple : EdgeType::hadamard;
            if (this->is_neighbor(id2_vertex[vid], id2_vertex[nbid], etype)) continue;
            add_edge(id2_vertex[vid], id2_vertex[nbid], etype);
        }
    }
    return true;
}

/**
 * @brief Generate tikz file
 *
 * @param filename
 * @return true if the filename is valid
 * @return false if not
 */
bool ZXGraph::write_tikz(std::string const& filename) const {
    std::ofstream tikz_file{filename};
    if (!tikz_file.is_open()) {
        spdlog::error("Cannot open the file \"{}\"!!", filename);
        return false;
    }

    return write_tikz(tikz_file);
}

/**
 * @brief write tikz file to the fstream `tikzFile`
 *
 * @param tikzFile
 * @return true if the filename is valid
 * @return false if not
 */
bool ZXGraph::write_tikz(std::ostream& os) const {
    static std::unordered_map<VertexType, std::string> const vt2s = {
        {VertexType::boundary, "boun"},
        {VertexType::z, "zspi"},
        {VertexType::x, "xspi"},
        {VertexType::h_box, "hbox"}};

    static std::unordered_map<EdgeType, std::string> const et2s = {
        {EdgeType::hadamard, "hedg"},
        {EdgeType::simple, "sedg"}};

    static constexpr std::string_view font_size = "tiny";

    // REVIEW - add scale
    // auto max_col = gsl::narrow_cast<int>(std::max(
    //     std::ranges::max(_inputs | std::views::transform([](ZXVertex* v) { return v->get_col(); })),
    //     std::ranges::max(_outputs | std::views::transform([](ZXVertex* v) { return v->get_col(); }))));

    // double scale = 25. / max_col;
    // scale        = (scale > 3.0) ? 3.0 : scale;

    auto get_attr_string = [](ZXVertex* v) {
        std::string result = vt2s.at(v->get_type());
        // don't print phase for zero-phase vertices, except for h-boxes we don't print when phase is pi.
        if ((v->get_phase() == Phase(0) && !v->is_hbox()) || (v->get_phase() == Phase(1) && v->is_hbox())) {
            return result;
        }

        std::string_view label_style = "[label distance=-2]90:{\\color{phaseColor}";

        auto numerator            = v->get_phase().numerator();
        std::string numerator_str = fmt::format("{}\\pi",
                                                numerator == 1    ? ""
                                                : numerator == -1 ? "-"
                                                                  : std::to_string(numerator));

        auto sans_serif_styled = [](auto const& val) { return fmt::format("\\mathsf{{{}}}", val); };

        auto denominator         = v->get_phase().denominator();
        std::string fraction_str = std::invoke([&]() -> std::string {
            if (denominator == 1) {
                return sans_serif_styled(numerator_str);
            } else {
                return fmt::format("\\frac{{{}}}{{{}}}", sans_serif_styled(numerator_str), sans_serif_styled(denominator));
            }
        });

        fmt::format_to(std::back_inserter(result), ", label={{{0} \\{1} ${2}$}}}}", label_style, font_size, fraction_str);
        return result;
    };

    fmt::println(os, "% Generated by qsyn " QSYN_VERSION ", DVLab, NTUEE");

    // color definition
    fmt::println(os, "\\definecolor{{zx_red}}{{RGB}}{{253, 160, 162}}");
    fmt::println(os, "\\definecolor{{zx_green}}{{RGB}}{{206, 254, 206}}");
    fmt::println(os, "\\definecolor{{hedgeColor}}{{RGB}}{{40, 160, 240}}");
    fmt::println(os, "\\definecolor{{phaseColor}}{{RGB}}{{14, 39, 100}}");
    fmt::println(os, "");
    // the main tikzpicture
    // REVIEW - add scale and replace 1
    fmt::println(os, "\\scalebox{{{}}}{{", 1);
    fmt::println(os, "    \\begin{{tikzpicture}}[");
    // node and edge styles
    fmt::println(os, "        font = \\sffamily,");
    fmt::println(os, "        yscale=-1,");
    fmt::println(os, "        boun/.style={{circle, text=yellow!60, font=\\sffamily, draw=black!100, fill=black!60, thick, text width=3mm, align=center, inner sep=0pt}},");
    fmt::println(os, "        hbox/.style={{regular polygon, regular polygon sides=4, font=\\sffamily, draw=yellow!40!black!100, fill=yellow!40, text width=2.5mm, align=center, inner sep=0pt}},");
    fmt::println(os, "        zspi/.style={{circle, font=\\sffamily, draw=green!60!black!100, fill=zx_green, text width=5mm, align=center, inner sep=0pt}},");
    fmt::println(os, "        xspi/.style={{circle, font=\\sffamily, draw=red!60!black!100, fill=zx_red, text width=5mm, align=center, inner sep=0pt}},");
    fmt::println(os, "        hedg/.style={{draw=hedgeColor, thick}},");
    fmt::println(os, "        sedg/.style={{draw=black, thick}},");
    fmt::println(os, "    ];");
    // content of the tikzpicture
    fmt::println(os, "        % vertices");
    // drawing vertices: \node[zspi] (88888)  at (0,1) {{\tiny 88888}};
    for (auto& v : get_vertices()) {
        fmt::println(os, "        \\node[{0}]({1})  at ({2}, {3}) {{{{\\{4} {1}}}}};", get_attr_string(v), v->get_id(), v->get_col(), v->get_row(), font_size);
    }  // end for vertices
    fmt::println(os, "");
    fmt::println(os, "        % edges");
    // drawing edges: \draw[hedg] (1234) -- (123);
    for (auto& v : _vertices) {
        for (auto& [n, e] : this->get_neighbors(v)) {
            if (n->get_id() > v->get_id()) {
                if (n->get_col() == v->get_col() && n->get_row() == v->get_row()) {
                    spdlog::warn("{} and {} are connected but they have same coordinates.", v->get_id(), n->get_id());
                    fmt::println(os, "        % \\draw[{0}] ({1}) -- ({2});", et2s.at(e), v->get_id(), n->get_id());
                } else {
                    fmt::println(os, "        \\draw[{0}] ({1}) -- ({2});", et2s.at(e), v->get_id(), n->get_id());
                }
            }
        }
    }
    fmt::println(os, "    \\end{{tikzpicture}}");
    fmt::println(os, "}}");
    return true;
}

/**
 * @brief Generate pdf file
 *
 * @param filename
 * @param toPDF if true, compile it to .pdf
 * @return true
 * @return false
 */
bool ZXGraph::write_pdf(std::string const& filename) const {
    if (!dvlab::utils::pdflatex_exists()) {
        spdlog::error("Unable to locate 'pdflatex' on your system. Please ensure that it is installed and in your system's PATH.");
        return false;
    }

    namespace fs = std::filesystem;
    namespace dv = dvlab::utils;
    fs::path filepath{filename};

    if (filepath.extension() == "") {
        spdlog::error("no file extension!!");
        return false;
    }

    if (filepath.extension() != ".pdf") {
        spdlog::error("unsupported file extension \"{}\"!!", filepath.extension().string());
        return false;
    }

    filepath.replace_extension(".tex");
    if (filepath.parent_path().empty()) {
        filepath = "./" + filepath.string();
    }

    std::error_code ec;
    fs::create_directory(filepath.parent_path(), ec);
    if (ec) {
        spdlog::error("failed to create the directory");
        spdlog::error("{}", ec.message());
        return false;
    }

    dv::TmpDir const tmp_dir;

    auto temp_tex_path = tmp_dir.path() / filepath.filename();

    std::ofstream tex_file{temp_tex_path};
    if (!tex_file.is_open()) {
        spdlog::error("Cannot open the file \"{}\"!!", filepath.string());
        return false;
    }

    if (!write_tex(tex_file)) return false;

    tex_file.close();

    // Unix cmd: pdflatex -halt-on-error -output-directory <path/to/dir> <path/to/tex>
    auto const cmd = fmt::format("pdflatex -halt-on-error -output-directory {0} {1} >/dev/null 2>&1", temp_tex_path.parent_path().string(), temp_tex_path.string());
    if (system(cmd.c_str()) != 0) {
        spdlog::error("failed to generate PDF");
        return false;
    }

    filepath.replace_extension(".pdf");

    if (fs::exists(filepath))
        fs::remove(filepath);

    // NOTE - copy instead of rename to avoid cross device link error
    fs::copy(temp_tex_path.replace_extension(".pdf"), filepath);

    return true;
}

/**
 * @brief Generate pdf file
 *
 * @param filename
 * @param toPDF if true, compile it to .pdf
 * @return true
 * @return false
 */
bool ZXGraph::write_tex(std::string const& filename) const {
    namespace fs = std::filesystem;
    fs::path const filepath{filename};

    if (filepath.extension() == "") {
        spdlog::error("no file extension!!");
        return false;
    }

    if (filepath.extension() != ".tex") {
        spdlog::error("unsupported file extension \"{}\"!!", filepath.extension().string());
        return false;
    }

    if (!filepath.parent_path().empty()) {
        std::error_code ec;
        fs::create_directory(filepath.parent_path(), ec);
        if (ec) {
            spdlog::error("failed to create the directory");
            spdlog::error("{}", ec.message());
            return false;
        }
    }

    std::ofstream tex_file{filepath};
    if (!tex_file.is_open()) {
        spdlog::error("Cannot open the file \"{}\"!!", filepath.string());
        return false;
    }

    return write_tex(tex_file);
}

/**
 * @brief Generate tex file
 *
 * @param filename
 * @return true if the filename is valid
 * @return false if not
 */
bool ZXGraph::write_tex(std::ostream& os) const {
    constexpr std::string_view includes =
        "\\documentclass[preview,border=2px]{standalone}\n"
        "\\usepackage[english]{babel}\n"
        "\\usepackage[top=2cm,bottom=2cm,left=1cm,right=1cm,marginparwidth=1.75cm]{geometry}"
        "\\usepackage{amsmath}\n"
        "\\usepackage{tikz}\n"
        "\\usetikzlibrary{shapes}\n"
        "\\usetikzlibrary{plotmarks}\n"
        "\\usepackage[colorlinks=true, allcolors=blue]{hyperref}\n"
        "\\usetikzlibrary{positioning}\n"
        "\\usetikzlibrary{shapes.geometric}\n";

    fmt::println(os, "{}", includes);
    fmt::println(os, "\\begin{{document}}\n");
    if (!write_tikz(os)) {
        spdlog::error("Failed to write tikz");
        return false;
    }
    fmt::println(os, "\\end{{document}}\n");
    return true;
}

}  // namespace qsyn::zx
