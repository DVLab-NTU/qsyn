/**
 * @file
 * @brief implementation of the todd phase polynomial optimization
 * @copyright Copyright(c) 2024 DVLab, GIEE, NTU, Taiwan
 */

#include <ranges>
#include <unordered_map>
#include <unordered_set>

#include "../tableau_optimization.hpp"
#include "tableau/pauli_rotation.hpp"
#include "tableau/stabilizer_tableau.hpp"
#include "util/boolean_matrix.hpp"
#include "util/ordered_hashmap.hpp"
#include "util/phase.hpp"
#include "util/util.hpp"

extern bool stop_requested();

namespace qsyn::tableau {

namespace {
using Polynomial = std::vector<PauliRotation>;

/**
 * @brief Get the products between rows. returns matrix[0] * matrix[1], matrix[0] * matrix[2], ... matrix[1] * matrix[2], ...
 *
 * @param a_prime
 * @return dvlab::BooleanMatrix
 */
dvlab::BooleanMatrix get_row_products(dvlab::BooleanMatrix const& matrix) {
    auto row_products = dvlab::BooleanMatrix();

    row_products.reserve(matrix.num_rows() * (matrix.num_rows() - 1) / 2, matrix.num_cols());

    for (auto const& [a, b] : dvlab::combinations<2>(std::views::iota(0ul, matrix.num_rows()) | tl::to<std::vector>())) {
        row_products.push_row(matrix[a] * matrix[b]);
    }

    assert(row_products.num_rows() == matrix.num_rows() * (matrix.num_rows() - 1) / 2);

    return row_products;
}

/**
 * @brief Get the chi matrix object
 *
 * @param row_products the products between rows generated by get_row_products
 * @param z
 * @return dvlab::BooleanMatrix
 */
dvlab::BooleanMatrix get_chi_matrix(dvlab::BooleanMatrix const& row_products, dvlab::BooleanMatrix::Row const& z) {
    auto chi_matrix     = dvlab::BooleanMatrix();
    auto const num_rows = static_cast<size_t>(std::ceil(std::sqrt(row_products.num_rows() * 2)));

    auto const get_row_product_idx = [&num_rows](size_t a, size_t b) {
        if (a > b) {
            std::swap(a, b);
        }
        return a * num_rows - (a * (a + 1) / 2) + b - a - 1;
    };

    auto seen_rows    = std::unordered_set<dvlab::BooleanMatrix::Row, dvlab::BooleanMatrixRowHash>();
    auto const id_vec = std::views::iota(0ul, num_rows) | tl::to<std::vector>();

    for (auto const& [a, b, c] : dvlab::combinations<3>(id_vec)) {
        auto const new_row =
            z[a] * row_products[get_row_product_idx(b, c)] +
            z[b] * row_products[get_row_product_idx(a, c)] +
            z[c] * row_products[get_row_product_idx(a, b)];

        if (seen_rows.contains(new_row)) {
            continue;
        }

        if (new_row.is_zeros()) {
            continue;
        }
        seen_rows.insert(new_row);

        chi_matrix.push_row(new_row);
    }

    return chi_matrix;
}

/**
 * @brief Get the nullspace of a matrix.
 *
 * @param matrix
 * @return dvlab::BooleanMatrix
 */
dvlab::BooleanMatrix get_nullspace_transposed(dvlab::BooleanMatrix const& matrix) {
    auto augmented = hstack(dvlab::transpose(matrix), dvlab::identity(matrix.num_cols()));

    auto n_rows = matrix.num_cols();
    auto n_cols = matrix.num_rows();

    auto curr_pivot = size_t{0};

    for (auto const col : std::views::iota(0ul, n_cols)) {
        if (augmented[curr_pivot][col] == 0) {
            for (auto const row : std::views::iota(curr_pivot + 1, n_rows)) {
                if (augmented[row][col] != 0) {
                    augmented[curr_pivot] += augmented[row];
                    break;
                }
            }
        }

        if (augmented[curr_pivot][col] == 0) {
            continue;
        }

        for (auto const row : std::views::iota(curr_pivot + 1, n_rows)) {
            if (augmented[row][col] != 0) {
                augmented[row] += augmented[curr_pivot];
            }
        }

        ++curr_pivot;

        if (curr_pivot == n_rows) {
            break;
        }
    }

    auto nullspace = dvlab::BooleanMatrix(augmented.num_rows() - curr_pivot, augmented.num_cols() - n_cols);

    for (auto const row : std::views::iota(curr_pivot, augmented.num_rows())) {
        for (auto const col : std::views::iota(n_cols, augmented.num_cols())) {
            nullspace[row - curr_pivot][col - n_cols] = augmented[row][col];
        }
    }

    return nullspace;
}

dvlab::BooleanMatrix load_phase_poly_matrix(Polynomial const& polynomial) {
    auto const n_qubits = polynomial.front().n_qubits();

    auto phase_poly_matrix = dvlab::BooleanMatrix(n_qubits, polynomial.size());

    for (size_t i = 0; i < n_qubits; ++i) {
        for (size_t j = 0; j < polynomial.size(); ++j) {
            phase_poly_matrix[i][j] = polynomial[j].pauli_product().is_z_set(i);
        }
    }

    return phase_poly_matrix;
}

/**
 * @brief convert a boolean matrix to a list of Pauli rotations. Every two duplicated terms are removed.
 *
 * @param matrix
 * @return std::vector<PauliRotation>
 */
std::vector<PauliRotation> from_boolean_matrix(dvlab::BooleanMatrix const& matrix) {
    auto term_count_map = dvlab::utils::ordered_hashmap<dvlab::BooleanMatrix::Row, size_t, dvlab::BooleanMatrixRowHash>();
    for (auto const& row : matrix) {
        if (row.sum() == 0) {
            continue;
        }
        if (term_count_map.contains(row)) {
            term_count_map[row]++;
        } else {
            term_count_map.emplace(row, 1);
        }
    }
    // return matrix |
    return term_count_map |
           std::views::filter([](auto const& pair) { return pair.second % 2 == 1; }) |
           std::views::keys |
           std::views::transform([](auto const& row) -> PauliRotation {
               auto const pauli_vec = row |
                                      std::views::transform([](auto const x) { return x == 1 ? Pauli::z : Pauli::i; });
               return {pauli_vec, dvlab::Phase(1, 4)};
           }) |
           tl::to<std::vector>();
}

Polynomial todd_once(Polynomial const& polynomial) {
    if (polynomial.empty()) {
        return polynomial;
    }

    auto const n_qubits = polynomial.front().n_qubits();

    // Each column represents a term in the phase polynomial, and each row represents a qubit.
    auto const phase_poly_matrix = load_phase_poly_matrix(polynomial);

    auto seen_z        = std::unordered_set<dvlab::BooleanMatrix::Row, dvlab::BooleanMatrixRowHash>();
    auto const idx_vec = std::views::iota(0ul, polynomial.size()) | tl::to<std::vector>();

    auto const row_products = get_row_products(phase_poly_matrix);
    for (auto const& [a, b] : dvlab::combinations<2>(idx_vec)) {
        if (stop_requested()) {
            return polynomial;
        }
        dvlab::BooleanMatrix::Row z(n_qubits);
        for (size_t k = 0; k < n_qubits; ++k) {
            z[k] = phase_poly_matrix[k][a] ^ phase_poly_matrix[k][b];
        }
        if (seen_z.contains(z)) {
            continue;
        }

        seen_z.insert(z);

        // auto const chi_matrix = get_chi_matrix(phase_poly_matrix, z);
        auto const chi_matrix           = get_chi_matrix(row_products, z);
        auto const augmented_matrix     = vstack(phase_poly_matrix, chi_matrix);
        auto const nullspace_transposed = get_nullspace_transposed(augmented_matrix);

        if (nullspace_transposed.is_empty()) {
            continue;
        }

        for (auto const& y : nullspace_transposed) {
            if (y[a] == y[b]) continue;
            spdlog::debug("Found a TODD move");
            spdlog::debug("- a, b: {}, {}", a, b);
            spdlog::debug("- z: {}", fmt::join(z, ""));
            spdlog::debug("- y: {}", fmt::join(y, ""));
            auto phase_poly_matrix_copy = phase_poly_matrix;
            auto y_copy                 = y;
            if (y_copy.sum() % 2 == 1) {
                phase_poly_matrix_copy.push_zeros_column();
                y_copy.emplace_back(1);
            }

            for (auto const i : std::views::iota(0ul, phase_poly_matrix_copy.num_rows())) {
                if (z[i] == 1) {
                    phase_poly_matrix_copy[i] += y_copy;
                }
            }

            return from_boolean_matrix(dvlab::transpose(phase_poly_matrix_copy));
        }
    }

    return polynomial;
}

}  // namespace

namespace {
class MultiLinearPolynomial {
public:
    void add_rotation(PauliRotation const& rotation, bool subtract = false) {
        if (!rotation.is_diagonal()) {
            return;
        }
        if (4 % rotation.phase().denominator() != 0) {
            return;
        }

        auto const ones =
            std::views::iota(0ul, rotation.n_qubits()) |
            std::views::filter([&rotation](size_t i) { return rotation.pauli_product().is_z_set(i); }) |
            tl::to<std::vector>();

        for (auto const& i : ones) {
            if (!_linear_terms.contains(i)) {
                _linear_terms.emplace(i, 0);
            }
            subtract ? _linear_terms[i] += 7 : _linear_terms[i] += 1;
            _linear_terms[i] %= 8;
        }

        for (auto const& [i, j] : dvlab::combinations<2>(ones)) {
            if (!_quadratic_terms.contains({i, j})) {
                _quadratic_terms.emplace(std::make_pair(i, j), 0);
            }
            subtract ? _quadratic_terms[{i, j}] += 3 : _quadratic_terms[{i, j}] += 1;
            _quadratic_terms[{i, j}] %= 4;
        }

        for (auto const& [i, j, k] : dvlab::combinations<3>(ones)) {
            if (!_cubic_terms.contains({i, j, k})) {
                _cubic_terms.emplace(i, j, k);
            } else {
                _cubic_terms.erase({i, j, k});
            }
        }
    }

    void add_rotations(std::vector<PauliRotation> const& rotations, bool subtract = false) {
        for (auto const& rotation : rotations) {
            add_rotation(rotation, subtract);
        }
    }

    bool is_clifford() const {
        return std::ranges::all_of(_linear_terms | std::views::values, [](size_t const& count) { return count % 2 == 0; }) &&
               std::ranges::all_of(_quadratic_terms | std::views::values, [](size_t const& count) { return count % 2 == 0; }) &&
               _cubic_terms.empty();
    }

    std::optional<CliffordOperatorString> extract_clifford_operators() const {
        if (!is_clifford()) {
            return std::nullopt;
        }

        auto clifford = CliffordOperatorString();
        for (auto const& [i, count] : _linear_terms) {
            switch (count) {
                case 0:
                    break;
                case 2:
                    clifford.emplace_back(CliffordOperatorType::s, std::array<size_t, 2>{i, 0});
                    break;
                case 4:
                    clifford.emplace_back(CliffordOperatorType::z, std::array<size_t, 2>{i, 0});
                    break;
                case 6:
                    clifford.emplace_back(CliffordOperatorType::sdg, std::array<size_t, 2>{i, 0});
                    break;
                default:
                    DVLAB_UNREACHABLE("The count should be 0, 2, 4, or 6");
            }
        }

        for (auto const& [pair, count] : _quadratic_terms) {
            auto const& [i, j] = pair;
            switch (count) {
                case 0:
                    break;
                case 2:
                    clifford.emplace_back(CliffordOperatorType::cz, std::array<size_t, 2>{i, j});
                    break;
                default:
                    DVLAB_UNREACHABLE("The count should be 0 or 2");
            }
        }

        return clifford;
    }

private:
    struct PairHash {
        size_t operator()(std::pair<size_t, size_t> const& pair) const {
            return std::hash<size_t>{}(pair.first) ^ std::hash<size_t>{}(pair.second);
        }
    };

    struct TripleHash {
        size_t operator()(std::tuple<size_t, size_t, size_t> const& triple) const {
            return std::hash<size_t>{}(std::get<0>(triple)) ^ std::hash<size_t>{}(std::get<1>(triple)) ^ std::hash<size_t>{}(std::get<2>(triple));
        }
    };

    std::unordered_map<size_t, size_t> _linear_terms;
    std::unordered_map<std::pair<size_t, size_t>, size_t, PairHash> _quadratic_terms;
    std::unordered_set<std::tuple<size_t, size_t, size_t>, TripleHash> _cubic_terms;
};
}  // namespace

std::pair<StabilizerTableau, Polynomial> ToddPhasePolynomialOptimizationStrategy::optimize(StabilizerTableau const& clifford, Polynomial const& polynomial) const {
    if (polynomial.empty()) {
        fmt::println("Polynomial is empty, returning the input Clifford and polynomial");
        return {clifford, polynomial};
    }

    if (std::ranges::any_of(polynomial, [](PauliRotation const& rotation) { return 4 % rotation.phase().denominator() != 0; })) {
        spdlog::error("Failed to perform TODD optimization: the polynomial contains a non-4th-root-of-unity phase!!");
        return {clifford, polynomial};
    }

    auto ret_clifford   = clifford;
    auto ret_polynomial = polynomial;

    properize(ret_clifford, ret_polynomial);

    auto multi_linear_polynomial = MultiLinearPolynomial();
    multi_linear_polynomial.add_rotations(ret_polynomial, false);

    spdlog::trace("Polynomial before TODD:\n{}", fmt::join(ret_polynomial, "\n"));
    spdlog::debug("num_terms before TODD: {}", ret_polynomial.size());

    while (true) {
        auto const num_terms = ret_polynomial.size();
        ret_polynomial       = todd_once(ret_polynomial);
        if (ret_polynomial.empty() || ret_polynomial.size() == num_terms) {
            break;
        }
        spdlog::trace("Polynomial after TODD:\n{}", fmt::join(ret_polynomial, "\n"));
        spdlog::debug("num_terms after TODD: {}", ret_polynomial.size());
    }

    multi_linear_polynomial.add_rotations(ret_polynomial, true);

    if (auto clifford_ops = multi_linear_polynomial.extract_clifford_operators(); clifford_ops.has_value()) {
        ret_clifford.apply(*clifford_ops);
    } else {
        spdlog::error("Failed to perform TODD optimization: the post-optimization polynomial does not have the same signature as the pre-optimization polynomial!!");
        return {clifford, polynomial};
    }

    return {ret_clifford, ret_polynomial};
}

}  // namespace qsyn::tableau
